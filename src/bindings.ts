// @ts-nocheck
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
  async selectMusicFolder(
    onEvent: TAURI_CHANNEL<MetadataEvent>,
  ): Promise<Result<string, FrontendError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("select_music_folder", { onEvent }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async getAlbumWithTracks(
    id: number,
  ): Promise<Result<AlbumWithTracks, FrontendError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("get_album_with_tracks", { id }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async getArtistWithAlbums(
    id: number,
  ): Promise<Result<ArtistWithAlbums, FrontendError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("get_artist_with_albums", { id }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async getAllAlbums(): Promise<Result<Albums[], FrontendError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("get_all_albums") };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async trackById(id: number): Promise<Result<Tracks, FrontendError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("track_by_id", { id }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async newPlaylist(name: string): Promise<Result<number, FrontendError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("new_playlist", { name }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async getAllPlaylists(): Promise<Result<Playlists[], FrontendError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("get_all_playlists") };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async addToPlaylist(
    playlistId: number,
    trackId: number,
  ): Promise<Result<null, FrontendError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("add_to_playlist", { playlistId, trackId }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async getPlaylistTracks(
    playlistId: number,
  ): Promise<Result<PlaylistWithTracks, FrontendError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("get_playlist_tracks", { playlistId }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async removeFromPlaylist(
    playlistId: number,
    trackId: number,
  ): Promise<Result<null, FrontendError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("remove_from_playlist", {
          playlistId,
          trackId,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async searchDb(searchStr: string): Promise<Result<Search[], FrontendError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("search_db", { searchStr }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async getAlbumsOffset(
    limit: number,
    offset: number,
  ): Promise<Result<Albums[], FrontendError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("get_albums_offset", { limit, offset }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async getTotalAlbums(): Promise<Result<number, FrontendError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("get_total_albums") };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async getBatchTrack(
    ids: number[],
  ): Promise<Result<(Tracks | null)[], FrontendError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("get_batch_track", { ids }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async playTrack(trackId: number): Promise<Result<null, FrontendError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("play_track", { trackId }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async pauseTrack(): Promise<Result<null, FrontendError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("pause_track") };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async resumeTrack(): Promise<Result<null, FrontendError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("resume_track") };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async seekTrack(
    position: number,
    resume: boolean,
  ): Promise<Result<null, FrontendError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("seek_track", { position, resume }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async setVolume(volume: number): Promise<Result<null, FrontendError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("set_volume", { volume }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async getPlayerState(): Promise<PlayerState> {
    return await TAURI_INVOKE("get_player_state");
  },
  async playerHasTrack(): Promise<boolean> {
    return await TAURI_INVOKE("player_has_track");
  },
  async getPlayerProgress(): Promise<number> {
    return await TAURI_INVOKE("get_player_progress");
  },
  async getPlayerDuration(): Promise<number> {
    return await TAURI_INVOKE("get_player_duration");
  },
  async stopPlayer(): Promise<Result<null, FrontendError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("stop_player") };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async initializePlayer(
    trackId: number,
    progress: number,
  ): Promise<Result<null, FrontendError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("initialize_player", { trackId, progress }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async setPlayerProgress(progress: number): Promise<void> {
    await TAURI_INVOKE("set_player_progress", { progress });
  },
  async playerHasEnded(): Promise<boolean> {
    return await TAURI_INVOKE("player_has_ended");
  },
  async playerProgressChannel(
    onEvent: TAURI_CHANNEL<PlayerProgressEvent>,
  ): Promise<Result<null, FrontendError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("player_progress_channel", { onEvent }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async getToken(): Promise<Result<[string, string], FrontendError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("get_token") };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async getSession(token: string): Promise<Result<null, FrontendError>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("get_session", { token }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async readCustomStyle(): Promise<Result<string, FrontendError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("read_custom_style") };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async readConfig(): Promise<Result<SodapopConfig, FrontendError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("read_config") };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async openUrl(url: string): Promise<Result<null, FrontendError>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("open_url", { url }) };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
};

/** user-defined events **/

export const events = __makeEvents__<{
  sodapopConfigEvent: SodapopConfigEvent;
}>({
  sodapopConfigEvent: "sodapop-config-event",
});

/** user-defined constants **/

/** user-defined types **/

export type AlbumType = "Unknown" | "Single" | "EP" | "Album";
export type AlbumWithTracks = {
  album: Albums;
  /**
   * All tracks belonging to album
   */
  tracks: Tracks[];
};
export type Albums = {
  /**
   * ID of album in database
   */
  id: number;
  /**
   * ID of artist in database
   */
  artist_id: number;
  /**
   * Name of artist
   */
  artist_name: string;
  /**
   * Name of album
   */
  name: string;
  /**
   * Year album was published
   */
  year: number;
  /**
   * Album type
   */
  album_type: AlbumType;
  /**
   * Amount of tracks in album
   */
  track_count: number;
  /**
   * Album duration
   */
  duration: number;
  /**
   * Path to album cover in Sodapop local app data
   */
  cover_path: string;
  /**
   * Path to album folder from where it was imported
   */
  path: string;
};
export type ArtistWithAlbums = {
  artist: Artists;
  /**
   * All albums belonging to artist
   */
  albums: AlbumWithTracks[];
};
export type Artists = {
  /**
   * ID of artist in database
   */
  id: number;
  /**
   * Name of artist
   */
  name: string;
};
export type FrontendError =
  | { type: "Io"; data: string }
  | { type: "Metadata"; data: string }
  | { type: "Database"; data: string }
  | { type: "Player"; data: string }
  | { type: "Standard"; data: string }
  | { type: "LastFMError"; data: string }
  | { type: "SerdeJson"; data: string }
  | { type: "TauriError"; data: string }
  | { type: "AnyhowError"; data: string };
export type MediaPayload =
  | { Play: boolean }
  | { Pause: boolean }
  | { Next: boolean }
  | { Previous: boolean }
  /**
   * Volume as f64 (0.0 - 1.0)
   */
  | { Volume: number }
  /**
   * Duration as f64
   */
  | { Seek: number }
  /**
   * Position in seconds
   */
  | { Position: number };
export type MetadataEvent =
  | { event: "Started"; data: { id: number; total: number } }
  | { event: "Progress"; data: { id: number; current: number } }
  | { event: "Finished"; data: { id: number } };
export type PlayerProgressEvent =
  | { event: "Progress"; data: { progress: number } }
  | { event: "TrackEnd" };
export type PlayerState = "Playing" | "Paused";
export type PlaylistWithTracks = {
  playlist: Playlists;
  /**
   * All tracks belonging to playlist
   */
  tracks: Tracks[];
};
export type Playlists = {
  /**
   * ID of playlist in database
   */
  id: number;
  /**
   * Playlist name
   */
  name: string;
  /**
   * Playlist description
   */
  description: string;
  /**
   * Path to playlist cover in Sodapop local app data
   */
  cover_path: string;
};
export type Search = {
  /**
   * ID of the search item
   */
  search_id: number;
  /**
   * Name of the search item
   */
  title: string;
  /**
   * Type of the search item
   */
  search_type: string;
};
export type SodapopConfig = {
  theme: ThemeMode;
  music_dir: string | null;
  discord_enabled: boolean;
  last_fm_enabled: boolean;
  last_fm_key: string | null;
};
export type SodapopConfigEvent = {
  theme: ThemeMode | null;
  discord_enabled: boolean | null;
  last_fm_enabled: boolean | null;
  music_dir: string | null;
  last_fm_key: string | null;
};
export type ThemeMode = "Dark" | "Light" | "System";
export type Tracks = {
  /**
   * ID of track in database
   */
  id: number;
  /**
   * ID of album in database
   */
  album_id: number;
  /**
   * ID of artist in database
   */
  artist_id: number;
  /**
   * Album name
   */
  album_name: string;
  /**
   * Artist name
   */
  artist_name: string;
  /**
   * Track name
   */
  name: string;
  /**
   * Track number in album
   */
  number: number;
  /**
   * Track duration
   */
  duration: number;
  /**
   * Path to album cover in Sodapop local app data
   */
  cover_path: string;
  /**
   * Path to track file
   */
  path: string;
};

/** tauri-specta globals **/

import {
  invoke as TAURI_INVOKE,
  Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
  listen: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
  once: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
  emit: null extends T
    ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
    : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
  | { status: "ok"; data: T }
  | { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
  mappings: Record<keyof T, string>,
) {
  return new Proxy(
    {} as unknown as {
      [K in keyof T]: __EventObj__<T[K]> & {
        (handle: __WebviewWindow__): __EventObj__<T[K]>;
      };
    },
    {
      get: (_, event) => {
        const name = mappings[event as keyof T];

        return new Proxy((() => {}) as any, {
          apply: (_, __, [window]: [__WebviewWindow__]) => ({
            listen: (arg: any) => window.listen(name, arg),
            once: (arg: any) => window.once(name, arg),
            emit: (arg: any) => window.emit(name, arg),
          }),
          get: (_, command: keyof __EventObj__<any>) => {
            switch (command) {
              case "listen":
                return (arg: any) => TAURI_API_EVENT.listen(name, arg);
              case "once":
                return (arg: any) => TAURI_API_EVENT.once(name, arg);
              case "emit":
                return (arg: any) => TAURI_API_EVENT.emit(name, arg);
            }
          },
        });
      },
    },
  );
}
